# 既存プロジェクトへの機能追加ルール

既存のコードベースに新機能を追加する際の原則とガイドライン。

## 基本原則

### 最小変更の原則
変更は必要最小限に留め、既存コードへの影響を最小化する。

### 既存パターンの尊重
プロジェクトの既存の設計思想、実装パターン、コーディングスタイルを最優先で踏襲する。

## 実装前の調査フェーズ

### 1. 既存機能の徹底調査

新しい関数・クラス・モジュールを追加する前に、必ず以下を調査する：

- **類似機能の存在確認**
  - 同じ目的を達成する既存機能がないか
  - 拡張可能な既存機能がないか
  - 部分的に再利用できるコードがないか

- **実装パターンの分析**
  - 同種の機能がどのように実装されているか
  - どのようなアーキテクチャパターンが使われているか
  - どのような命名規則が使われているか

### 2. コーディングスタイルの調査

プロジェクト全体の一貫性を保つため、以下を確認する：

- **命名規則**
  - 変数名（camelCase、snake_case、等）
  - 関数名（動詞始まり、名詞始まり、等）
  - クラス名（PascalCase、接頭辞・接尾辞の使用、等）
  - ファイル名（拡張子、ディレクトリ構造、等）

- **コードフォーマット**
  - インデント（スペース、タブ、サイズ）
  - 括弧の位置（K&R、Allman、等）
  - 行の長さ制限
  - 空行の使い方

- **コメントスタイル**
  - JSDoc/TSDoc/Docstring の使用
  - インラインコメントの頻度と形式
  - TODO/FIXME の記述方法

- **エラーハンドリング**
  - 例外の使用パターン
  - エラーメッセージの形式
  - ロギングの方法

### 3. アーキテクチャパターンの調査

- **デザインパターン**
  - 使用されているデザインパターン（Singleton、Factory、Observer、等）
  - 依存性注入の方法
  - イベントハンドリングの仕組み

- **モジュール構造**
  - ディレクトリ構造の意図
  - モジュール間の依存関係
  - 公開API vs 内部実装の分離

- **状態管理**
  - グローバル状態の管理方法
  - データフローのパターン
  - 副作用の扱い方

### 4. テスト戦略の調査

- **テストの種類**
  - 単体テスト、統合テスト、E2Eテストの比率
  - テストフレームワークとライブラリ
  - モック・スタブの使用パターン

- **テストファイルの配置**
  - テストファイルの命名規則
  - テストディレクトリの構造
  - テストデータの管理方法

## 実装時の判断基準

### 既存機能の拡張 vs 新規実装

以下の優先順位で判断する：

1. **既存機能をそのまま使用できるか**
   - パラメータの追加や変更で対応可能か
   - 設定ファイルの変更で対応可能か

2. **既存機能を拡張できるか**
   - 継承・コンポジションで機能追加できるか
   - プラグイン機構があれば利用できるか
   - フックやコールバックで拡張できるか

3. **既存機能を参考に新規実装**
   - 同様のパターンで実装できるか
   - 既存のユーティリティ関数を再利用できるか

4. **完全な新規実装が必要**
   - 上記すべてが不可能な場合のみ
   - 既存パターンとの一貫性を保つ

### コード追加時のチェックリスト

- [ ] 同じ機能を持つコードが既に存在しないか確認した
- [ ] 既存の類似機能を調査し、そのパターンを理解した
- [ ] プロジェクトの命名規則に従っている
- [ ] プロジェクトのコードフォーマットに従っている
- [ ] 既存のアーキテクチャパターンに沿っている
- [ ] 既存のエラーハンドリング方法に従っている
- [ ] 既存のテスト戦略に沿ったテストを追加した
- [ ] 必要最小限の変更に留めている

## 具体例

### 悪い例：勝手に新しいユーティリティ関数を追加

```javascript
// 既存のプロジェクトに dateUtils.js というファイルがあることに気づかず追加
function formatDate(date) {
  return date.toISOString().split('T')[0];
}
```

### 良い例：既存のユーティリティを調査して使用

```javascript
// 既存の utils/dateUtils.js を確認
import { formatToISO } from './utils/dateUtils';

// 既存関数がそのまま使えることを確認
const formattedDate = formatToISO(new Date());
```

### 悪い例：プロジェクトのパターンを無視

```javascript
// プロジェクトでは async/await を使っているのに Promise.then() を使用
function fetchData() {
  return fetch('/api/data')
    .then(response => response.json())
    .then(data => processData(data));
}
```

### 良い例：既存パターンに従う

```javascript
// 既存コードを調査し、async/await パターンを踏襲
async function fetchData() {
  const response = await fetch('/api/data');
  const data = await response.json();
  return processData(data);
}
```

## 実装ワークフロー

1. **要件理解**
   - 追加する機能の目的と範囲を明確にする

2. **既存コード調査**（必須）
   - 類似機能の存在確認
   - 実装パターンの分析
   - コーディングスタイルの確認

3. **実装方針の決定**
   - 既存機能の利用/拡張/新規のいずれかを選択
   - 既存パターンへの適合性を確認

4. **最小実装**
   - 必要最小限のコード変更
   - 既存コードの修正は慎重に

5. **テスト追加**
   - 既存のテスト戦略に沿ったテスト
   - リグレッションの確認

6. **レビュー**
   - 既存パターンとの一貫性
   - 変更の妥当性と最小性

## 禁止事項

- 既存機能の調査を怠り、重複するコードを追加すること
- プロジェクトのコーディングスタイルを無視すること
- 既存のアーキテクチャパターンを無視した実装
- 不要な依存関係の追加
- 過度な抽象化や将来の拡張性を考慮しすぎた実装
- 既存コードの動作を変える不必要なリファクタリング

## 変更の最小化テクニック

### 1. パラメータの追加で対応
```javascript
// 既存関数にオプショナルパラメータを追加
function processData(data, options = {}) {
  // 新機能はオプションで制御
  if (options.newFeature) {
    // 新機能の処理
  }
  // 既存の処理
}
```

### 2. 設定ファイルでの制御
```javascript
// config.js に新しい設定を追加
export default {
  // 既存設定
  existingFeature: true,
  // 新機能の設定
  newFeature: {
    enabled: false,
    options: {}
  }
};
```

### 3. 継承による拡張
```javascript
// 既存クラスを継承して機能追加
class ExtendedClass extends ExistingClass {
  newMethod() {
    // 新機能
  }
}
```

### 4. コンポジションによる拡張
```javascript
// 既存機能をラップして機能追加
class EnhancedFeature {
  constructor(existingFeature) {
    this.existingFeature = existingFeature;
  }

  enhance() {
    // 既存機能を利用しながら拡張
    const result = this.existingFeature.process();
    return this.addNewFeature(result);
  }
}
```

## まとめ

既存プロジェクトへの機能追加は、**調査**と**最小変更**が鍵。

1. 徹底的に既存コードを調査する
2. 既存パターンを最大限尊重する
3. 変更は必要最小限に留める
4. 新しいコードを追加する前に既存コードで実現できないか検討する
